(globalThis.TURBOPACK = globalThis.TURBOPACK || []).push(["chunks/ssr/node_modules_next_dist_compiled_react-server-dom-webpack_client_743b4e.js", {

"[project]/node_modules/next/dist/compiled/react-server-dom-webpack/cjs/react-server-dom-webpack-client.browser.development.js (ecmascript, ssr)": (function({ r: __turbopack_require__, f: __turbopack_require_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, l: __turbopack_load__, j: __turbopack_dynamic__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, k: __turbopack_refresh__, m: module, e: exports }) { !function() {

'use strict';
if ("TURBOPACK compile-time truthy", 1) {
    (function() {
        'use strict';
        var ReactDOM = __turbopack_require__("[project]/node_modules/next/dist/compiled/react-dom/server-rendering-stub.js (ecmascript, ssr)");
        var React = __turbopack_require__("[project]/node_modules/next/dist/compiled/react/index.js (ecmascript, ssr)");
        var enableBinaryFlight = false;
        function createStringDecoder() {
            return new TextDecoder();
        }
        var decoderOptions = {
            stream: true
        };
        function readPartialStringChunk(decoder, buffer) {
            return decoder.decode(buffer, decoderOptions);
        }
        function readFinalStringChunk(decoder, buffer) {
            return decoder.decode(buffer);
        }
        function resolveClientReference(bundlerConfig, metadata) {
            if (bundlerConfig) {
                var moduleExports = bundlerConfig[metadata.id];
                var resolvedModuleData = moduleExports[metadata.name];
                var name;
                if (resolvedModuleData) {
                    name = resolvedModuleData.name;
                } else {
                    resolvedModuleData = moduleExports['*'];
                    if (!resolvedModuleData) {
                        throw new Error('Could not find the module "' + metadata.id + '" in the React SSR Manifest. ' + 'This is probably a bug in the React Server Components bundler.');
                    }
                    name = metadata.name;
                }
                return {
                    id: resolvedModuleData.id,
                    chunks: resolvedModuleData.chunks,
                    name: name,
                    async: !!metadata.async
                };
            }
            return metadata;
        }
        var chunkCache = new Map();
        function requireAsyncModule(id) {
            var promise = globalThis.__next_require__(id);
            if (typeof promise.then !== 'function') {
                return null;
            } else if (promise.status === 'fulfilled') {
                return null;
            } else {
                promise.then(function(value) {
                    var fulfilledThenable = promise;
                    fulfilledThenable.status = 'fulfilled';
                    fulfilledThenable.value = value;
                }, function(reason) {
                    var rejectedThenable = promise;
                    rejectedThenable.status = 'rejected';
                    rejectedThenable.reason = reason;
                });
                return promise;
            }
        }
        function ignoreReject() {}
        function preloadModule(metadata) {
            var chunks = metadata.chunks;
            var promises = [];
            for(var i = 0; i < chunks.length; i++){
                var chunkId = chunks[i];
                var entry = chunkCache.get(chunkId);
                if (entry === undefined) {
                    var thenable = globalThis.__next_chunk_load__(chunkId);
                    promises.push(thenable);
                    var resolve = chunkCache.set.bind(chunkCache, chunkId, null);
                    thenable.then(resolve, ignoreReject);
                    chunkCache.set(chunkId, thenable);
                } else if (entry !== null) {
                    promises.push(entry);
                }
            }
            if (metadata.async) {
                if (promises.length === 0) {
                    return requireAsyncModule(metadata.id);
                } else {
                    return Promise.all(promises).then(function() {
                        return requireAsyncModule(metadata.id);
                    });
                }
            } else if (promises.length > 0) {
                return Promise.all(promises);
            } else {
                return null;
            }
        }
        function requireModule(metadata) {
            var moduleExports = globalThis.__next_require__(metadata.id);
            if (metadata.async) {
                if (typeof moduleExports.then !== 'function') ;
                else if (moduleExports.status === 'fulfilled') {
                    moduleExports = moduleExports.value;
                } else {
                    throw moduleExports.reason;
                }
            }
            if (metadata.name === '*') {
                return moduleExports;
            }
            if (metadata.name === '') {
                return moduleExports.__esModule ? moduleExports.default : moduleExports;
            }
            return moduleExports[metadata.name];
        }
        var ReactDOMSharedInternals = ReactDOM.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
        var ReactDOMCurrentDispatcher = ReactDOMSharedInternals.Dispatcher;
        function dispatchHint(code, model) {
            var dispatcher = ReactDOMCurrentDispatcher.current;
            if (dispatcher) {
                var href, options;
                if (typeof model === 'string') {
                    href = model;
                } else {
                    href = model[0];
                    options = model[1];
                }
                switch(code){
                    case 'D':
                        {
                            dispatcher.prefetchDNS(href, options);
                            return;
                        }
                    case 'C':
                        {
                            dispatcher.preconnect(href, options);
                            return;
                        }
                    case 'L':
                        {
                            dispatcher.preload(href, options);
                            return;
                        }
                    case 'I':
                        {
                            dispatcher.preinit(href, options);
                            return;
                        }
                }
            }
        }
        var ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
        function error(format) {
            {
                {
                    for(var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++){
                        args[_key2 - 1] = arguments[_key2];
                    }
                    printWarning('error', format, args);
                }
            }
        }
        function printWarning(level, format, args) {
            {
                var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
                var stack = ReactDebugCurrentFrame.getStackAddendum();
                if (stack !== '') {
                    format += '%s';
                    args = args.concat([
                        stack
                    ]);
                }
                var argsWithFormat = args.map(function(item) {
                    return String(item);
                });
                argsWithFormat.unshift('Warning: ' + format);
                Function.prototype.apply.call(console[level], console, argsWithFormat);
            }
        }
        var REACT_ELEMENT_TYPE = Symbol.for('react.element');
        var REACT_PROVIDER_TYPE = Symbol.for('react.provider');
        var REACT_FORWARD_REF_TYPE = Symbol.for('react.forward_ref');
        var REACT_SUSPENSE_TYPE = Symbol.for('react.suspense');
        var REACT_SUSPENSE_LIST_TYPE = Symbol.for('react.suspense_list');
        var REACT_MEMO_TYPE = Symbol.for('react.memo');
        var REACT_LAZY_TYPE = Symbol.for('react.lazy');
        var REACT_SERVER_CONTEXT_DEFAULT_VALUE_NOT_LOADED = Symbol.for('react.default_value');
        var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
        var FAUX_ITERATOR_SYMBOL = '@@iterator';
        function getIteratorFn(maybeIterable) {
            if (maybeIterable === null || typeof maybeIterable !== 'object') {
                return null;
            }
            var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];
            if (typeof maybeIterator === 'function') {
                return maybeIterator;
            }
            return null;
        }
        var isArrayImpl = Array.isArray;
        function isArray(a) {
            return isArrayImpl(a);
        }
        var jsxPropsParents = new WeakMap();
        var jsxChildrenParents = new WeakMap();
        function isObjectPrototype(object) {
            if (!object) {
                return false;
            }
            var ObjectPrototype = Object.prototype;
            if (object === ObjectPrototype) {
                return true;
            }
            if (Object.getPrototypeOf(object)) {
                return false;
            }
            var names = Object.getOwnPropertyNames(object);
            for(var i = 0; i < names.length; i++){
                if (!(names[i] in ObjectPrototype)) {
                    return false;
                }
            }
            return true;
        }
        function isSimpleObject(object) {
            if (!isObjectPrototype(Object.getPrototypeOf(object))) {
                return false;
            }
            var names = Object.getOwnPropertyNames(object);
            for(var i = 0; i < names.length; i++){
                var descriptor = Object.getOwnPropertyDescriptor(object, names[i]);
                if (!descriptor) {
                    return false;
                }
                if (!descriptor.enumerable) {
                    if ((names[i] === 'key' || names[i] === 'ref') && typeof descriptor.get === 'function') {
                        continue;
                    }
                    return false;
                }
            }
            return true;
        }
        function objectName(object) {
            var name = Object.prototype.toString.call(object);
            return name.replace(/^\[object (.*)\]$/, function(m, p0) {
                return p0;
            });
        }
        function describeKeyForErrorMessage(key) {
            var encodedKey = JSON.stringify(key);
            return '"' + key + '"' === encodedKey ? key : encodedKey;
        }
        function describeValueForErrorMessage(value) {
            switch(typeof value){
                case 'string':
                    {
                        return JSON.stringify(value.length <= 10 ? value : value.slice(0, 10) + '...');
                    }
                case 'object':
                    {
                        if (isArray(value)) {
                            return '[...]';
                        }
                        var name = objectName(value);
                        if (name === 'Object') {
                            return '{...}';
                        }
                        return name;
                    }
                case 'function':
                    return 'function';
                default:
                    return String(value);
            }
        }
        function describeElementType(type) {
            if (typeof type === 'string') {
                return type;
            }
            switch(type){
                case REACT_SUSPENSE_TYPE:
                    return 'Suspense';
                case REACT_SUSPENSE_LIST_TYPE:
                    return 'SuspenseList';
            }
            if (typeof type === 'object') {
                switch(type.$$typeof){
                    case REACT_FORWARD_REF_TYPE:
                        return describeElementType(type.render);
                    case REACT_MEMO_TYPE:
                        return describeElementType(type.type);
                    case REACT_LAZY_TYPE:
                        {
                            var lazyComponent = type;
                            var payload = lazyComponent._payload;
                            var init = lazyComponent._init;
                            try {
                                return describeElementType(init(payload));
                            } catch (x) {}
                        }
                }
            }
            return '';
        }
        function describeObjectForErrorMessage(objectOrArray, expandedName) {
            var objKind = objectName(objectOrArray);
            if (objKind !== 'Object' && objKind !== 'Array') {
                return objKind;
            }
            var str = '';
            var start = -1;
            var length = 0;
            if (isArray(objectOrArray)) {
                if (jsxChildrenParents.has(objectOrArray)) {
                    var type = jsxChildrenParents.get(objectOrArray);
                    str = '<' + describeElementType(type) + '>';
                    var array = objectOrArray;
                    for(var i = 0; i < array.length; i++){
                        var value = array[i];
                        var substr = void 0;
                        if (typeof value === 'string') {
                            substr = value;
                        } else if (typeof value === 'object' && value !== null) {
                            substr = '{' + describeObjectForErrorMessage(value) + '}';
                        } else {
                            substr = '{' + describeValueForErrorMessage(value) + '}';
                        }
                        if ('' + i === expandedName) {
                            start = str.length;
                            length = substr.length;
                            str += substr;
                        } else if (substr.length < 15 && str.length + substr.length < 40) {
                            str += substr;
                        } else {
                            str += '{...}';
                        }
                    }
                    str += '</' + describeElementType(type) + '>';
                } else {
                    str = '[';
                    var _array = objectOrArray;
                    for(var _i = 0; _i < _array.length; _i++){
                        if (_i > 0) {
                            str += ', ';
                        }
                        var _value = _array[_i];
                        var _substr = void 0;
                        if (typeof _value === 'object' && _value !== null) {
                            _substr = describeObjectForErrorMessage(_value);
                        } else {
                            _substr = describeValueForErrorMessage(_value);
                        }
                        if ('' + _i === expandedName) {
                            start = str.length;
                            length = _substr.length;
                            str += _substr;
                        } else if (_substr.length < 10 && str.length + _substr.length < 40) {
                            str += _substr;
                        } else {
                            str += '...';
                        }
                    }
                    str += ']';
                }
            } else {
                if (objectOrArray.$$typeof === REACT_ELEMENT_TYPE) {
                    str = '<' + describeElementType(objectOrArray.type) + '/>';
                } else if (jsxPropsParents.has(objectOrArray)) {
                    var _type = jsxPropsParents.get(objectOrArray);
                    str = '<' + (describeElementType(_type) || '...');
                    var object = objectOrArray;
                    var names = Object.keys(object);
                    for(var _i2 = 0; _i2 < names.length; _i2++){
                        str += ' ';
                        var name = names[_i2];
                        str += describeKeyForErrorMessage(name) + '=';
                        var _value2 = object[name];
                        var _substr2 = void 0;
                        if (name === expandedName && typeof _value2 === 'object' && _value2 !== null) {
                            _substr2 = describeObjectForErrorMessage(_value2);
                        } else {
                            _substr2 = describeValueForErrorMessage(_value2);
                        }
                        if (typeof _value2 !== 'string') {
                            _substr2 = '{' + _substr2 + '}';
                        }
                        if (name === expandedName) {
                            start = str.length;
                            length = _substr2.length;
                            str += _substr2;
                        } else if (_substr2.length < 10 && str.length + _substr2.length < 40) {
                            str += _substr2;
                        } else {
                            str += '...';
                        }
                    }
                    str += '>';
                } else {
                    str = '{';
                    var _object = objectOrArray;
                    var _names = Object.keys(_object);
                    for(var _i3 = 0; _i3 < _names.length; _i3++){
                        if (_i3 > 0) {
                            str += ', ';
                        }
                        var _name = _names[_i3];
                        str += describeKeyForErrorMessage(_name) + ': ';
                        var _value3 = _object[_name];
                        var _substr3 = void 0;
                        if (typeof _value3 === 'object' && _value3 !== null) {
                            _substr3 = describeObjectForErrorMessage(_value3);
                        } else {
                            _substr3 = describeValueForErrorMessage(_value3);
                        }
                        if (_name === expandedName) {
                            start = str.length;
                            length = _substr3.length;
                            str += _substr3;
                        } else if (_substr3.length < 10 && str.length + _substr3.length < 40) {
                            str += _substr3;
                        } else {
                            str += '...';
                        }
                    }
                    str += '}';
                }
            }
            if (expandedName === undefined) {
                return str;
            }
            if (start > -1 && length > 0) {
                var highlight = ' '.repeat(start) + '^'.repeat(length);
                return '\n  ' + str + '\n  ' + highlight;
            }
            return '\n  ' + str;
        }
        var knownServerReferences = new WeakMap();
        function serializePromiseID(id) {
            return '$@' + id.toString(16);
        }
        function serializeServerReferenceID(id) {
            return '$F' + id.toString(16);
        }
        function serializeSymbolReference(name) {
            return '$S' + name;
        }
        function serializeFormDataReference(id) {
            return '$K' + id.toString(16);
        }
        function serializeNumber(number) {
            if (Number.isFinite(number)) {
                if (number === 0 && 1 / number === -Infinity) {
                    return '$-0';
                } else {
                    return number;
                }
            } else {
                if (number === Infinity) {
                    return '$Infinity';
                } else if (number === -Infinity) {
                    return '$-Infinity';
                } else {
                    return '$NaN';
                }
            }
        }
        function serializeUndefined() {
            return '$undefined';
        }
        function serializeDateFromDateJSON(dateJSON) {
            return '$D' + dateJSON;
        }
        function serializeBigInt(n) {
            return '$n' + n.toString(10);
        }
        function serializeMapID(id) {
            return '$Q' + id.toString(16);
        }
        function serializeSetID(id) {
            return '$W' + id.toString(16);
        }
        function escapeStringValue(value) {
            if (value[0] === '$') {
                return '$' + value;
            } else {
                return value;
            }
        }
        function processReply(root, formFieldPrefix, resolve, reject) {
            var nextPartId = 1;
            var pendingParts = 0;
            var formData = null;
            function resolveToJSON(key, value) {
                var parent = this;
                {
                    var originalValue = parent[key];
                    if (typeof originalValue === 'object' && originalValue !== value && !(originalValue instanceof Date)) {
                        if (objectName(originalValue) !== 'Object') {
                            error('Only plain objects can be passed to Server Functions from the Client. ' + '%s objects are not supported.%s', objectName(originalValue), describeObjectForErrorMessage(parent, key));
                        } else {
                            error('Only plain objects can be passed to Server Functions from the Client. ' + 'Objects with toJSON methods are not supported. Convert it manually ' + 'to a simple value before passing it to props.%s', describeObjectForErrorMessage(parent, key));
                        }
                    }
                }
                if (value === null) {
                    return null;
                }
                if (typeof value === 'object') {
                    if (typeof value.then === 'function') {
                        if (formData === null) {
                            formData = new FormData();
                        }
                        pendingParts++;
                        var promiseId = nextPartId++;
                        var thenable = value;
                        thenable.then(function(partValue) {
                            var partJSON = JSON.stringify(partValue, resolveToJSON);
                            var data = formData;
                            data.append(formFieldPrefix + promiseId, partJSON);
                            pendingParts--;
                            if (pendingParts === 0) {
                                resolve(data);
                            }
                        }, function(reason) {
                            reject(reason);
                        });
                        return serializePromiseID(promiseId);
                    }
                    if (value instanceof FormData) {
                        if (formData === null) {
                            formData = new FormData();
                        }
                        var data = formData;
                        var refId = nextPartId++;
                        var prefix = formFieldPrefix + refId + '_';
                        value.forEach(function(originalValue, originalKey) {
                            data.append(prefix + originalKey, originalValue);
                        });
                        return serializeFormDataReference(refId);
                    }
                    if (value instanceof Map) {
                        var partJSON = JSON.stringify(Array.from(value), resolveToJSON);
                        if (formData === null) {
                            formData = new FormData();
                        }
                        var mapId = nextPartId++;
                        formData.append(formFieldPrefix + mapId, partJSON);
                        return serializeMapID(mapId);
                    }
                    if (value instanceof Set) {
                        var _partJSON = JSON.stringify(Array.from(value), resolveToJSON);
                        if (formData === null) {
                            formData = new FormData();
                        }
                        var setId = nextPartId++;
                        formData.append(formFieldPrefix + setId, _partJSON);
                        return serializeSetID(setId);
                    }
                    if (!isArray(value)) {
                        var iteratorFn = getIteratorFn(value);
                        if (iteratorFn) {
                            return Array.from(value);
                        }
                    }
                    {
                        if (value !== null && !isArray(value)) {
                            if (value.$$typeof === REACT_ELEMENT_TYPE) {
                                error('React Element cannot be passed to Server Functions from the Client.%s', describeObjectForErrorMessage(parent, key));
                            } else if (value.$$typeof === REACT_LAZY_TYPE) {
                                error('React Lazy cannot be passed to Server Functions from the Client.%s', describeObjectForErrorMessage(parent, key));
                            } else if (value.$$typeof === REACT_PROVIDER_TYPE) {
                                error('React Context Providers cannot be passed to Server Functions from the Client.%s', describeObjectForErrorMessage(parent, key));
                            } else if (objectName(value) !== 'Object') {
                                error('Only plain objects can be passed to Client Components from Server Components. ' + '%s objects are not supported.%s', objectName(value), describeObjectForErrorMessage(parent, key));
                            } else if (!isSimpleObject(value)) {
                                error('Only plain objects can be passed to Client Components from Server Components. ' + 'Classes or other objects with methods are not supported.%s', describeObjectForErrorMessage(parent, key));
                            } else if (Object.getOwnPropertySymbols) {
                                var symbols = Object.getOwnPropertySymbols(value);
                                if (symbols.length > 0) {
                                    error('Only plain objects can be passed to Client Components from Server Components. ' + 'Objects with symbol properties like %s are not supported.%s', symbols[0].description, describeObjectForErrorMessage(parent, key));
                                }
                            }
                        }
                    }
                    return value;
                }
                if (typeof value === 'string') {
                    if (value[value.length - 1] === 'Z') {
                        var _originalValue = parent[key];
                        if (_originalValue instanceof Date) {
                            return serializeDateFromDateJSON(value);
                        }
                    }
                    return escapeStringValue(value);
                }
                if (typeof value === 'boolean') {
                    return value;
                }
                if (typeof value === 'number') {
                    return serializeNumber(value);
                }
                if (typeof value === 'undefined') {
                    return serializeUndefined();
                }
                if (typeof value === 'function') {
                    var metaData = knownServerReferences.get(value);
                    if (metaData !== undefined) {
                        var metaDataJSON = JSON.stringify(metaData, resolveToJSON);
                        if (formData === null) {
                            formData = new FormData();
                        }
                        var _refId = nextPartId++;
                        formData.set(formFieldPrefix + _refId, metaDataJSON);
                        return serializeServerReferenceID(_refId);
                    }
                    throw new Error('Client Functions cannot be passed directly to Server Functions. ' + 'Only Functions passed from the Server can be passed back again.');
                }
                if (typeof value === 'symbol') {
                    var name = value.description;
                    if (Symbol.for(name) !== value) {
                        throw new Error('Only global symbols received from Symbol.for(...) can be passed to Server Functions. ' + ("The symbol Symbol.for(" + value.description + ") cannot be found among global symbols."));
                    }
                    return serializeSymbolReference(name);
                }
                if (typeof value === 'bigint') {
                    return serializeBigInt(value);
                }
                throw new Error("Type " + typeof value + " is not supported as an argument to a Server Function.");
            }
            var json = JSON.stringify(root, resolveToJSON);
            if (formData === null) {
                resolve(json);
            } else {
                formData.set(formFieldPrefix + '0', json);
                if (pendingParts === 0) {
                    resolve(formData);
                }
            }
        }
        function createServerReference(id, callServer) {
            var proxy = function() {
                var args = Array.prototype.slice.call(arguments);
                return callServer(id, args);
            };
            knownServerReferences.set(proxy, {
                id: id,
                bound: null
            });
            return proxy;
        }
        var ContextRegistry = ReactSharedInternals.ContextRegistry;
        function getOrCreateServerContext(globalName) {
            if (!ContextRegistry[globalName]) {
                ContextRegistry[globalName] = React.createServerContext(globalName, REACT_SERVER_CONTEXT_DEFAULT_VALUE_NOT_LOADED);
            }
            return ContextRegistry[globalName];
        }
        var ROW_ID = 0;
        var ROW_TAG = 1;
        var ROW_LENGTH = 2;
        var ROW_CHUNK_BY_NEWLINE = 3;
        var ROW_CHUNK_BY_LENGTH = 4;
        var PENDING = 'pending';
        var BLOCKED = 'blocked';
        var RESOLVED_MODEL = 'resolved_model';
        var RESOLVED_MODULE = 'resolved_module';
        var INITIALIZED = 'fulfilled';
        var ERRORED = 'rejected';
        function Chunk(status, value, reason, response) {
            this.status = status;
            this.value = value;
            this.reason = reason;
            this._response = response;
        }
        Chunk.prototype = Object.create(Promise.prototype);
        Chunk.prototype.then = function(resolve, reject) {
            var chunk = this;
            switch(chunk.status){
                case RESOLVED_MODEL:
                    initializeModelChunk(chunk);
                    break;
                case RESOLVED_MODULE:
                    initializeModuleChunk(chunk);
                    break;
            }
            switch(chunk.status){
                case INITIALIZED:
                    resolve(chunk.value);
                    break;
                case PENDING:
                case BLOCKED:
                    if (resolve) {
                        if (chunk.value === null) {
                            chunk.value = [];
                        }
                        chunk.value.push(resolve);
                    }
                    if (reject) {
                        if (chunk.reason === null) {
                            chunk.reason = [];
                        }
                        chunk.reason.push(reject);
                    }
                    break;
                default:
                    reject(chunk.reason);
                    break;
            }
        };
        function readChunk(chunk) {
            switch(chunk.status){
                case RESOLVED_MODEL:
                    initializeModelChunk(chunk);
                    break;
                case RESOLVED_MODULE:
                    initializeModuleChunk(chunk);
                    break;
            }
            switch(chunk.status){
                case INITIALIZED:
                    return chunk.value;
                case PENDING:
                case BLOCKED:
                    throw chunk;
                default:
                    throw chunk.reason;
            }
        }
        function getRoot(response) {
            var chunk = getChunk(response, 0);
            return chunk;
        }
        function createPendingChunk(response) {
            return new Chunk(PENDING, null, null, response);
        }
        function createBlockedChunk(response) {
            return new Chunk(BLOCKED, null, null, response);
        }
        function createErrorChunk(response, error) {
            return new Chunk(ERRORED, null, error, response);
        }
        function wakeChunk(listeners, value) {
            for(var i = 0; i < listeners.length; i++){
                var listener = listeners[i];
                listener(value);
            }
        }
        function wakeChunkIfInitialized(chunk, resolveListeners, rejectListeners) {
            switch(chunk.status){
                case INITIALIZED:
                    wakeChunk(resolveListeners, chunk.value);
                    break;
                case PENDING:
                case BLOCKED:
                    chunk.value = resolveListeners;
                    chunk.reason = rejectListeners;
                    break;
                case ERRORED:
                    if (rejectListeners) {
                        wakeChunk(rejectListeners, chunk.reason);
                    }
                    break;
            }
        }
        function triggerErrorOnChunk(chunk, error) {
            if (chunk.status !== PENDING && chunk.status !== BLOCKED) {
                return;
            }
            var listeners = chunk.reason;
            var erroredChunk = chunk;
            erroredChunk.status = ERRORED;
            erroredChunk.reason = error;
            if (listeners !== null) {
                wakeChunk(listeners, error);
            }
        }
        function createResolvedModelChunk(response, value) {
            return new Chunk(RESOLVED_MODEL, value, null, response);
        }
        function createResolvedModuleChunk(response, value) {
            return new Chunk(RESOLVED_MODULE, value, null, response);
        }
        function createInitializedTextChunk(response, value) {
            return new Chunk(INITIALIZED, value, null, response);
        }
        function resolveModelChunk(chunk, value) {
            if (chunk.status !== PENDING) {
                return;
            }
            var resolveListeners = chunk.value;
            var rejectListeners = chunk.reason;
            var resolvedChunk = chunk;
            resolvedChunk.status = RESOLVED_MODEL;
            resolvedChunk.value = value;
            if (resolveListeners !== null) {
                initializeModelChunk(resolvedChunk);
                wakeChunkIfInitialized(chunk, resolveListeners, rejectListeners);
            }
        }
        function resolveModuleChunk(chunk, value) {
            if (chunk.status !== PENDING && chunk.status !== BLOCKED) {
                return;
            }
            var resolveListeners = chunk.value;
            var rejectListeners = chunk.reason;
            var resolvedChunk = chunk;
            resolvedChunk.status = RESOLVED_MODULE;
            resolvedChunk.value = value;
            if (resolveListeners !== null) {
                initializeModuleChunk(resolvedChunk);
                wakeChunkIfInitialized(chunk, resolveListeners, rejectListeners);
            }
        }
        var initializingChunk = null;
        var initializingChunkBlockedModel = null;
        function initializeModelChunk(chunk) {
            var prevChunk = initializingChunk;
            var prevBlocked = initializingChunkBlockedModel;
            initializingChunk = chunk;
            initializingChunkBlockedModel = null;
            try {
                var value = parseModel(chunk._response, chunk.value);
                if (initializingChunkBlockedModel !== null && initializingChunkBlockedModel.deps > 0) {
                    initializingChunkBlockedModel.value = value;
                    var blockedChunk = chunk;
                    blockedChunk.status = BLOCKED;
                    blockedChunk.value = null;
                    blockedChunk.reason = null;
                } else {
                    var initializedChunk = chunk;
                    initializedChunk.status = INITIALIZED;
                    initializedChunk.value = value;
                }
            } catch (error) {
                var erroredChunk = chunk;
                erroredChunk.status = ERRORED;
                erroredChunk.reason = error;
            } finally{
                initializingChunk = prevChunk;
                initializingChunkBlockedModel = prevBlocked;
            }
        }
        function initializeModuleChunk(chunk) {
            try {
                var value = requireModule(chunk.value);
                var initializedChunk = chunk;
                initializedChunk.status = INITIALIZED;
                initializedChunk.value = value;
            } catch (error) {
                var erroredChunk = chunk;
                erroredChunk.status = ERRORED;
                erroredChunk.reason = error;
            }
        }
        function reportGlobalError(response, error) {
            response._chunks.forEach(function(chunk) {
                if (chunk.status === PENDING) {
                    triggerErrorOnChunk(chunk, error);
                }
            });
        }
        function createElement(type, key, props) {
            var element = {
                $$typeof: REACT_ELEMENT_TYPE,
                type: type,
                key: key,
                ref: null,
                props: props,
                _owner: null
            };
            {
                element._store = {};
                Object.defineProperty(element._store, 'validated', {
                    configurable: false,
                    enumerable: false,
                    writable: true,
                    value: true
                });
                Object.defineProperty(element, '_self', {
                    configurable: false,
                    enumerable: false,
                    writable: false,
                    value: null
                });
                Object.defineProperty(element, '_source', {
                    configurable: false,
                    enumerable: false,
                    writable: false,
                    value: null
                });
            }
            return element;
        }
        function createLazyChunkWrapper(chunk) {
            var lazyType = {
                $$typeof: REACT_LAZY_TYPE,
                _payload: chunk,
                _init: readChunk
            };
            return lazyType;
        }
        function getChunk(response, id) {
            var chunks = response._chunks;
            var chunk = chunks.get(id);
            if (!chunk) {
                chunk = createPendingChunk(response);
                chunks.set(id, chunk);
            }
            return chunk;
        }
        function createModelResolver(chunk, parentObject, key) {
            var blocked;
            if (initializingChunkBlockedModel) {
                blocked = initializingChunkBlockedModel;
                blocked.deps++;
            } else {
                blocked = initializingChunkBlockedModel = {
                    deps: 1,
                    value: null
                };
            }
            return function(value) {
                parentObject[key] = value;
                blocked.deps--;
                if (blocked.deps === 0) {
                    if (chunk.status !== BLOCKED) {
                        return;
                    }
                    var resolveListeners = chunk.value;
                    var initializedChunk = chunk;
                    initializedChunk.status = INITIALIZED;
                    initializedChunk.value = blocked.value;
                    if (resolveListeners !== null) {
                        wakeChunk(resolveListeners, blocked.value);
                    }
                }
            };
        }
        function createModelReject(chunk) {
            return function(error) {
                return triggerErrorOnChunk(chunk, error);
            };
        }
        function createServerReferenceProxy(response, metaData) {
            var callServer = response._callServer;
            var proxy = function() {
                var args = Array.prototype.slice.call(arguments);
                var p = metaData.bound;
                if (!p) {
                    return callServer(metaData.id, args);
                }
                if (p.status === INITIALIZED) {
                    var bound = p.value;
                    return callServer(metaData.id, bound.concat(args));
                }
                return Promise.resolve(p).then(function(bound) {
                    return callServer(metaData.id, bound.concat(args));
                });
            };
            knownServerReferences.set(proxy, metaData);
            return proxy;
        }
        function getOutlinedModel(response, id) {
            var chunk = getChunk(response, id);
            switch(chunk.status){
                case RESOLVED_MODEL:
                    initializeModelChunk(chunk);
                    break;
            }
            switch(chunk.status){
                case INITIALIZED:
                    {
                        return chunk.value;
                    }
                default:
                    throw chunk.reason;
            }
        }
        function parseModelString(response, parentObject, key, value) {
            if (value[0] === '$') {
                if (value === '$') {
                    return REACT_ELEMENT_TYPE;
                }
                switch(value[1]){
                    case '$':
                        {
                            return value.slice(1);
                        }
                    case 'L':
                        {
                            var id = parseInt(value.slice(2), 16);
                            var chunk = getChunk(response, id);
                            return createLazyChunkWrapper(chunk);
                        }
                    case '@':
                        {
                            var _id = parseInt(value.slice(2), 16);
                            var _chunk = getChunk(response, _id);
                            return _chunk;
                        }
                    case 'S':
                        {
                            return Symbol.for(value.slice(2));
                        }
                    case 'P':
                        {
                            return getOrCreateServerContext(value.slice(2)).Provider;
                        }
                    case 'F':
                        {
                            var _id2 = parseInt(value.slice(2), 16);
                            var metadata = getOutlinedModel(response, _id2);
                            return createServerReferenceProxy(response, metadata);
                        }
                    case 'Q':
                        {
                            var _id3 = parseInt(value.slice(2), 16);
                            var data = getOutlinedModel(response, _id3);
                            return new Map(data);
                        }
                    case 'W':
                        {
                            var _id4 = parseInt(value.slice(2), 16);
                            var _data = getOutlinedModel(response, _id4);
                            return new Set(_data);
                        }
                    case 'I':
                        {
                            return Infinity;
                        }
                    case '-':
                        {
                            if (value === '$-0') {
                                return -0;
                            } else {
                                return -Infinity;
                            }
                        }
                    case 'N':
                        {
                            return NaN;
                        }
                    case 'u':
                        {
                            return undefined;
                        }
                    case 'D':
                        {
                            return new Date(Date.parse(value.slice(2)));
                        }
                    case 'n':
                        {
                            return BigInt(value.slice(2));
                        }
                    default:
                        {
                            var _id5 = parseInt(value.slice(1), 16);
                            var _chunk2 = getChunk(response, _id5);
                            switch(_chunk2.status){
                                case RESOLVED_MODEL:
                                    initializeModelChunk(_chunk2);
                                    break;
                                case RESOLVED_MODULE:
                                    initializeModuleChunk(_chunk2);
                                    break;
                            }
                            switch(_chunk2.status){
                                case INITIALIZED:
                                    return _chunk2.value;
                                case PENDING:
                                case BLOCKED:
                                    var parentChunk = initializingChunk;
                                    _chunk2.then(createModelResolver(parentChunk, parentObject, key), createModelReject(parentChunk));
                                    return null;
                                default:
                                    throw _chunk2.reason;
                            }
                        }
                }
            }
            return value;
        }
        function parseModelTuple(response, value) {
            var tuple = value;
            if (tuple[0] === REACT_ELEMENT_TYPE) {
                return createElement(tuple[1], tuple[2], tuple[3]);
            }
            return value;
        }
        function missingCall() {
            throw new Error('Trying to call a function from "use server" but the callServer option ' + 'was not implemented in your router runtime.');
        }
        function createResponse(bundlerConfig, callServer) {
            var chunks = new Map();
            var response = {
                _bundlerConfig: bundlerConfig,
                _callServer: callServer !== undefined ? callServer : missingCall,
                _chunks: chunks,
                _stringDecoder: createStringDecoder(),
                _fromJSON: null,
                _rowState: 0,
                _rowID: 0,
                _rowTag: 0,
                _rowLength: 0,
                _buffer: []
            };
            response._fromJSON = createFromJSONCallback(response);
            return response;
        }
        function resolveModel(response, id, model) {
            var chunks = response._chunks;
            var chunk = chunks.get(id);
            if (!chunk) {
                chunks.set(id, createResolvedModelChunk(response, model));
            } else {
                resolveModelChunk(chunk, model);
            }
        }
        function resolveText(response, id, text) {
            var chunks = response._chunks;
            chunks.set(id, createInitializedTextChunk(response, text));
        }
        function resolveModule(response, id, model) {
            var chunks = response._chunks;
            var chunk = chunks.get(id);
            var clientReferenceMetadata = parseModel(response, model);
            var clientReference = resolveClientReference(response._bundlerConfig, clientReferenceMetadata);
            var promise = preloadModule(clientReference);
            if (promise) {
                var blockedChunk;
                if (!chunk) {
                    blockedChunk = createBlockedChunk(response);
                    chunks.set(id, blockedChunk);
                } else {
                    blockedChunk = chunk;
                    blockedChunk.status = BLOCKED;
                }
                promise.then(function() {
                    return resolveModuleChunk(blockedChunk, clientReference);
                }, function(error) {
                    return triggerErrorOnChunk(blockedChunk, error);
                });
            } else {
                if (!chunk) {
                    chunks.set(id, createResolvedModuleChunk(response, clientReference));
                } else {
                    resolveModuleChunk(chunk, clientReference);
                }
            }
        }
        function resolveErrorDev(response, id, digest, message, stack) {
            var error = new Error(message || 'An error occurred in the Server Components render but no message was provided');
            error.stack = stack;
            error.digest = digest;
            var errorWithDigest = error;
            var chunks = response._chunks;
            var chunk = chunks.get(id);
            if (!chunk) {
                chunks.set(id, createErrorChunk(response, errorWithDigest));
            } else {
                triggerErrorOnChunk(chunk, errorWithDigest);
            }
        }
        function resolveHint(response, code, model) {
            var hintModel = parseModel(response, model);
            dispatchHint(code, hintModel);
        }
        function processFullRow(response, id, tag, buffer, chunk) {
            var stringDecoder = response._stringDecoder;
            var row = '';
            for(var i = 0; i < buffer.length; i++){
                row += readPartialStringChunk(stringDecoder, buffer[i]);
            }
            row += readFinalStringChunk(stringDecoder, chunk);
            switch(tag){
                case 73:
                    {
                        resolveModule(response, id, row);
                        return;
                    }
                case 72:
                    {
                        var code = row[0];
                        resolveHint(response, code, row.slice(1));
                        return;
                    }
                case 69:
                    {
                        var errorInfo = JSON.parse(row);
                        {
                            resolveErrorDev(response, id, errorInfo.digest, errorInfo.message, errorInfo.stack);
                        }
                        return;
                    }
                case 84:
                    {
                        resolveText(response, id, row);
                        return;
                    }
                default:
                    {
                        resolveModel(response, id, row);
                        return;
                    }
            }
        }
        function processBinaryChunk(response, chunk) {
            var i = 0;
            var rowState = response._rowState;
            var rowID = response._rowID;
            var rowTag = response._rowTag;
            var rowLength = response._rowLength;
            var buffer = response._buffer;
            var chunkLength = chunk.length;
            while(i < chunkLength){
                var lastIdx = -1;
                switch(rowState){
                    case ROW_ID:
                        {
                            var byte = chunk[i++];
                            if (byte === 58) {
                                rowState = ROW_TAG;
                            } else {
                                rowID = rowID << 4 | (byte > 96 ? byte - 87 : byte - 48);
                            }
                            continue;
                        }
                    case ROW_TAG:
                        {
                            var resolvedRowTag = chunk[i];
                            if (resolvedRowTag === 84 || enableBinaryFlight) {
                                rowTag = resolvedRowTag;
                                rowState = ROW_LENGTH;
                                i++;
                            } else if (resolvedRowTag > 64 && resolvedRowTag < 91) {
                                rowTag = resolvedRowTag;
                                rowState = ROW_CHUNK_BY_NEWLINE;
                                i++;
                            } else {
                                rowTag = 0;
                                rowState = ROW_CHUNK_BY_NEWLINE;
                            }
                            continue;
                        }
                    case ROW_LENGTH:
                        {
                            var _byte = chunk[i++];
                            if (_byte === 44) {
                                rowState = ROW_CHUNK_BY_LENGTH;
                            } else {
                                rowLength = rowLength << 4 | (_byte > 96 ? _byte - 87 : _byte - 48);
                            }
                            continue;
                        }
                    case ROW_CHUNK_BY_NEWLINE:
                        {
                            lastIdx = chunk.indexOf(10, i);
                            break;
                        }
                    case ROW_CHUNK_BY_LENGTH:
                        {
                            lastIdx = i + rowLength;
                            if (lastIdx > chunk.length) {
                                lastIdx = -1;
                            }
                            break;
                        }
                }
                var offset = chunk.byteOffset + i;
                if (lastIdx > -1) {
                    var length = lastIdx - i;
                    var lastChunk = new Uint8Array(chunk.buffer, offset, length);
                    processFullRow(response, rowID, rowTag, buffer, lastChunk);
                    i = lastIdx;
                    if (rowState === ROW_CHUNK_BY_NEWLINE) {
                        i++;
                    }
                    rowState = ROW_ID;
                    rowTag = 0;
                    rowID = 0;
                    rowLength = 0;
                    buffer.length = 0;
                } else {
                    var _length = chunk.byteLength - i;
                    var remainingSlice = new Uint8Array(chunk.buffer, offset, _length);
                    buffer.push(remainingSlice);
                    rowLength -= remainingSlice.byteLength;
                    break;
                }
            }
            response._rowState = rowState;
            response._rowID = rowID;
            response._rowTag = rowTag;
            response._rowLength = rowLength;
        }
        function parseModel(response, json) {
            return JSON.parse(json, response._fromJSON);
        }
        function createFromJSONCallback(response) {
            return function(key, value) {
                if (typeof value === 'string') {
                    return parseModelString(response, this, key, value);
                }
                if (typeof value === 'object' && value !== null) {
                    return parseModelTuple(response, value);
                }
                return value;
            };
        }
        function close(response) {
            reportGlobalError(response, new Error('Connection closed.'));
        }
        function createResponseFromOptions(options) {
            return createResponse(null, options && options.callServer ? options.callServer : undefined);
        }
        function startReadingFromStream(response, stream) {
            var reader = stream.getReader();
            function progress(_ref) {
                var done = _ref.done, value = _ref.value;
                if (done) {
                    close(response);
                    return;
                }
                var buffer = value;
                processBinaryChunk(response, buffer);
                return reader.read().then(progress).catch(error);
            }
            function error(e) {
                reportGlobalError(response, e);
            }
            reader.read().then(progress).catch(error);
        }
        function createFromReadableStream(stream, options) {
            var response = createResponseFromOptions(options);
            startReadingFromStream(response, stream);
            return getRoot(response);
        }
        function createFromFetch(promiseForResponse, options) {
            var response = createResponseFromOptions(options);
            promiseForResponse.then(function(r) {
                startReadingFromStream(response, r.body);
            }, function(e) {
                reportGlobalError(response, e);
            });
            return getRoot(response);
        }
        function encodeReply(value) {
            return new Promise(function(resolve, reject) {
                processReply(value, '', resolve, reject);
            });
        }
        exports.createFromFetch = createFromFetch;
        exports.createFromReadableStream = createFromReadableStream;
        exports.createServerReference = createServerReference;
        exports.encodeReply = encodeReply;
    })();
}

}.call(this) }),
"[project]/node_modules/next/dist/compiled/react-server-dom-webpack/client.browser.js (ecmascript, ssr)": (function({ r: __turbopack_require__, f: __turbopack_require_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, l: __turbopack_load__, j: __turbopack_dynamic__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, k: __turbopack_refresh__, m: module, e: exports }) { !function() {

'use strict';
if ("TURBOPACK compile-time falsy", 0) {
    "TURBOPACK unreachable";
} else {
    module.exports = __turbopack_require__("[project]/node_modules/next/dist/compiled/react-server-dom-webpack/cjs/react-server-dom-webpack-client.browser.development.js (ecmascript, ssr)");
}

}.call(this) }),
"[project]/node_modules/next/dist/compiled/react-server-dom-webpack/client.js (ecmascript, ssr)": (function({ r: __turbopack_require__, f: __turbopack_require_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, l: __turbopack_load__, j: __turbopack_dynamic__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, k: __turbopack_refresh__, m: module, e: exports }) { !function() {

'use strict';
module.exports = __turbopack_require__("[project]/node_modules/next/dist/compiled/react-server-dom-webpack/client.browser.js (ecmascript, ssr)");

}.call(this) }),
}]);

//# sourceMappingURL=node_modules_next_dist_compiled_react-server-dom-webpack_client_743b4e.js.map